var help = require('help');
help.global.globalize();
globalize(help.propConstr);
globalize(help.func, Function.prototype);
globalize(help.Func, Function);

const DBG_MODE = true;
const TEST_MODE = true;
var empty = {},
    Cache;

Cache = Function.create(function (back) {
    var inst;
    
    return inst = Function.create(function () {
	dbg(DBG_MODE, '\n++CACHE++');
	dbg(DBG_MODE, 'inst: Bananas - {\n\t*', inst.bananas.join('\n\t* '), '\n}');
	var args = Array.prototype.slice.call(arguments, 0);
	var banana = Cache.genBanana(args);
	
	var i = inst.getI(banana);
	dbg(DBG_MODE, 'inst: index - ', i, '/', args);
	var result;
	if (isI(i)) {
	    dbg(DBG_MODE, 'inst: Match ...');
	    result = inst.results[i];
	} else {
	    dbg(DBG_MODE, 'inst: Miss ...');
	    result = inst.back.apply(inst, args);
	    inst.add(banana, result);
	};
	dbg(DBG_MODE, '--CACHE--\n');
	
	return result;
    }, Cache.prototype, {
	back: ConstItem(back),
	bananas: StatItem([
	    [],
	    [],
	    []
	]),
	results: StatItem([])
    });
}, undefined, {
    hash: Meth.trigger(function () { // workaround to delay Cache call
	return this.val || (this.val = new Cache(function () {
	    var hash;
	    for (var hash; isI(this.results.indexOf(hash = Math.random())););
	    
	    return hash;
	}));
    }),
    genBanana: Meth(function (args) {
	var filledArgs = args.concat([empty, empty]);
	dbg(DBG_MODE, 'genBanana: filledArgs - ', filledArgs);
	var banana = new Array(3);
	var bigArgs = args.slice(2);
	dbg(DBG_MODE, '\n++HASH++');
	banana[0] = 0 < bigArgs.length ? Cache.hash.apply(undefined, bigArgs) : empty;
	dbg(DBG_MODE, '--HASH--\n');
	banana[1] = filledArgs[0];
	banana[2] = filledArgs[1];		
	dbg(DBG_MODE, 'genBanana: Banana - ', banana);
	
	return banana;
    }),
    prototype: Member(Object.create(Function.prototype, {
	add: Meth(function (banana, result) {
	    var inst = this;
	    dbg(DBG_MODE, '\n++ADD++');
	    dbg(DBG_MODE, 'add: banana - ', banana);
	    var length = banana.reduce(function (left, right, colI) {
		    dbg(DBG_MODE, 'reduce: colI - ', colI, '; right:', right);
		    return inst.bananas[colI].push(right);
		}, undefined);
	    this.results[length-1] = result;
	    dbg(DBG_MODE, 'add: bananas - ', this.bananas, '; results - ', this.results, '; length - ', length);
	    dbg(DBG_MODE, '--ADD--\n');
	    
	    return length;
	}),
	getI: Meth(function (banana) {
	    dbg(DBG_MODE, '\n++GETI++');
	    var inst = this;
	    var matchingI = this.bananas[0].reduce(function (left, right, i) {
		    dbg(DBG_MODE, '\n{{', i,'}}REDUCE: left - ', left, ' (', isI(left), ')');
		    return isI.argBack(left, function () {
			dbg(DBG_MODE, 'default: marchingI - ', bindMeth(inst, 'cmpBanana', banana).argIf(i, -1));
			return bindMeth(inst, 'cmpBanana', banana).argIf(i, -1);
		    });
		}, -1);
	    dbg(DBG_MODE, '--GETI--\n');
	    
	    return matchingI;
	}),
	cmpBanana: Meth(function (banana, i) {
	    var inst = this;
	    return banana.reduce(function (left, right, colI) {
		dbg(DBG_MODE, 'cmpBanana: left - ', left, '; right - ', right, '; _ - ', inst.bananas[colI][i], '; result - ', right === inst.bananas[colI][i]);
		return left && right === inst.bananas[colI][i];
	    }, true);
	})
    }))
});
    
module.exports = new Cache(Cache); // Same arguments singleton