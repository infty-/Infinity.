var constr = require('constr');
var HTable = require('comb').collections.HashTable;
var sift = require('sift');
var help = require('help');
help.global.globalize();
globalize(help.propConstr);
globalize(help.func, Function.prototype);
globalize(help.Func, Function);

var ObjCommiter = module.exports = Function.create(function (emitter, victim) {
	constr(CommitObj, this);
	
	baby.emitter = emitter;
	baby.victim = victim;
	baby.pairs = new HTable;
	
	return baby;
    }, undefined, {
	prototype: Member(Object.create(Object.prototype, {
	    props: ConstItem.trigger(function () {
		return this.pairs.keys;
	    }),
	    commit: Meth(function (editedProps) {
		this.commitTotal();
		
		var propListeners = this.getPropListeners(),
		    curProps = Object.getOwnPropertyNames(this.victim);
		if (0 < propListeners.length) { // is anyone intersted in that data?
		    editedProps = Array.isArray.arg(editedProps)
			|| 'string' === typeof editedProps
			? editedProps
			: curProps; // If editedProps' unspecified, every prop is potentally edited
		    
		    var ages = this.getPropsAges(curProps, editedProps),
			agesKeys = Object.keys(ages),
			agesNatKeys = sift({$ne: 'mature'}, agesKeys);
		    
		    agesNatKeys.forEach(function (ages_Key) {
			var ages_ = ages[ages_Key];
			var commitItem = bindMeth(this, 'commitProp', ages_Key);
			ages_.forEach(commitItem);
		    });
		    
		    this.commitEdits(editedProps); // TODO commit only mature props
		};
		//
	    }),
	    commitEdits: Meth(function (editedProps) {
		// TODO execute this code in order to update `this.pairs`, even if there aren't any `propListeners`
		var pairsEnts = this.pairs.entrySet;
		var editedPairs = new HTable;
			
		editedProps.map(function (editedProps_) {
		    var val = this.victim[editedProps_];
		    
		    editedPairs.put(editedProps_, val);
		});
		
		var editedEnts = editedPairs.entrySet; // TODO only use mature props (new props are already commited as `new`)
		var changedEnts = sift({$not: {$or: pairsEnt}}, editedEnts);
		var commitChange = bindMeth(this, 'commitProp', 'change');
		changedEnts.forEach(function (changedEnts_) {
		    commitChange(changedEnts_.value);
		});
		
		var pairs = this.pairs.concat(new HTable); // cloning `this.pairs`
		ages.died.forEach(pairs.remove); // TODO get `ages` variable into this execution context
		pairs = editedPairs.concat(pairs); // TODO only use mature and new pairs for concating
		this.pairs = pairs;
		// TODO compute new this.pairs (also think of died and new properties)
	    }),
	    commitTotal: Meth(function () {
		this.emit(['total', this.victim], this.victim);
	    }),
	    commitProp: Meth(function (action, prop) {
		var val = this.victim[prop],
		    ns = ['prop', this.victim, prop, action],
		    handlerArgs = [ns].concat([val]),
		    emitArgs = [ns].concat(handlerArgs);
		
		bindMeth(this, 'emit').apply(undefined, emitArgs);
	    }),
	    getPropListeners: Meth(function () {
		return this.listeners(['props', this.victim, '**']);
	    }),
	    getPropsAges: Meth(function (curProps, editedProps) {
		var nu,
		    died;
		
		return {
		    'new': nu = sift({$nin: this.props}, editedProps),
		    died: died = sift({$nin: curProps}, editedProps),
		    mature: sift({$and: [{$nin: nu}, {$nin: died}]}, editedProps)
		};
	    })
	}))
    );