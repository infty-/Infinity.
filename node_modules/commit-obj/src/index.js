var constr = require('constr');
var sift = require('sift');
var help = require('help');
help.global.globalize();
globalize(help.propConstr);
globalize(help.func, Function.prototype);
globalize(help.Func, Function);

var ObjCommiter = module.exports = Function.create(function (emitter, victim) {
	constr(CommitObj, this);
	
	baby.emitter = emitter;
	baby.victim = victim;
	baby.props = [];	
	
	return baby;
    }, undefined, {
	prototype: Member(Object.create(Object.prototype, {
	    commit: Meth(function (editedProps) {
		this.commitTotal();
		
		var propListeners = this.listeners(['props', obj, '**']),
		    curProps = Object.getOwnPropertyNames(this.victim);
		if (0 < propListeners.length) {
		    var ages = this.getPropsAges(curProps),
			nats = sift(); //TODO define sift
		    for (var ages_Key in ages) {
			var ages_ = ages[ages_Key];
			var commitItem = bindMeth(this, 'commitProp', ages_Key); // TODO does bindMeth really already support argument binding
			ages_.forEach(commitItem);
		    };
		    // TODO handle matures
		};
		this.props = curProps;
	    }),
	    commitTotal: Meth(function () {
		this.emit(['total', this.victim]);
	    }),
	    commitProp: Meth(function (action, prop) {
		this.emit(['prop', this.victim, prop, action]);
	    }),
	    getPropsAges: Meth(function (curProps) {
		return {
		    new: sift({$nin: this.props}, curProps),
		    mature: sift({$in: this.props}, curProps),
		    died: sift({$nin: curProps}, this.props)
		};
	    })
	}))
    );