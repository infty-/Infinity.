var constr = require('constr');
var HTable = require('comb').collections.HashTable;
var sift = require('sift');
var help = require('help');
help.global.globalize();
globalize(help.propConstr);
globalize(help.func, Function.prototype);
globalize(help.Func, Function);

var ObjCommiter = module.exports = Function.create(function (emitter, victim) {
	constr(CommitObj, this);
	
	baby.emitter = emitter;
	baby.victim = victim;
	baby.pairs = new HTable;
	
	return baby;
    }, undefined, {
	prototype: Member(Object.create(Object.prototype, {
	    props: ConstItem.trigger(function () {
		return this.pairs.keys;
	    }),
	    commit: Meth(function (editedProps) {
		this.commitTotal();
		
		var changeListeners = this.getChangeListeners(),
		    curProps = Object.getOwnPropertyNames(this.victim),
		    editedPairs = this.genEditedPairs(editedProps),
		    editedProps = Array.isArray.arg(editedProps)
			|| ('string' === typeof editedProps // Just the name of one prop - in this case
			    ? [editedProps]
			    : curProps
			   ); // If editedProps' unspecified, every prop was potentally edited
		    
		var ages = this.getPropsAges(curProps, editedProps);
		    
		this.commitNats(ages); // nat(ural)s ... new, died		    
		changeListeners.length > 0 && this.commitEdits(editedPairs); // Only commit if anyone is intersted
		
		this.pairs = this.genPairs(editedPairs, ages);
	    }),
	    genEditedPairs: Meth(function (editedProps) {
		var editedPairs = new HTable;
		
		editedProps.forEach(function (editedProps_) {
		    var val = this.victim[editedProps_];
		    
		    editedPairs.put(editedProps_, val);
		});
		
		return editedProps;
	    }),
	    genPairs: Meth(function (editedPairs, ages) {
		var pairs = this.pairs.concat(new HTable); // cloning `this.pairs`
		
		ages.died.forEach(pairs.remove);
		pairs = editedPairs.concat(pairs);
		
		return pairs;
	    }),
	    commitNats: Meth(function (ages) {
		var agesKeys = Object.keys(ages),
		    agesNatKeys = sift({$ne: 'mature'}, agesKeys);		
		
		agesNatKeys.forEach(function (ages_Key) {
		    var ages_ = ages[ages_Key];
		    var commitItem = bindMeth(this, 'commitProp', ages_Key);
		    
		    ages_.forEach(commitItem);
		});
	    }),
	    commitEdits: Meth(function (editedPairs) {
		var pairsEnts = this.pairs.entrySet,
		editedEnts = editedPairs.entrySet,
		changedEnts = sift({$not: {$or: pairsEnt}}, editedEnts),
		commitChange = bindMeth(this, 'commitProp', 'change');
		
		changedEnts.forEach(function (changedEnts_) {
		    commitChange(changedEnts_.value);
		});
	    }),
	    commitTotal: Meth(function () {
		this.emit(['total', this.victim], this.victim);
	    }),
	    commitProp: Meth(function (action, prop) {
		var val = this.victim[prop],
		    ns = ['prop', this.victim, '.' + prop, action], // `.` prop prefix in order to make `*` as prop name possible
		    handlerArgs = [ns].concat([val]),
		    emitArgs = [ns].concat(handlerArgs);
		
		bindMeth(this, 'emit').apply(undefined, emitArgs);
	    }),
	    getChangeListeners: Meth(function () {
		return this.listeners(['props', this.victim, '*', 'change']); // `*` .. wildcard
	    }),
	    getPropsAges: Meth(function (curProps, editedProps) {
		var nu,
		    died;
		
		return {
		    'new': nu = sift({$nin: this.props}, editedProps),
		    died: died = sift({$nin: curProps}, editedProps),
		    mature: sift({$and: [{$nin: nu}, {$nin: died}]}, editedProps)
		};
	    })
	}))
    );