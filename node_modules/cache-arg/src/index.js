var help = require('help');
help.global.globalize();
globalize(help.propConstr);
globalize(help.func, Function.prototype);
globalize(help.Func, Function);

const DBG_MODE = true;
const TEST_MODE = true;
var empty = {},
    Cache;

Cache = Function.create(function (back) {
    var inst;
    
    return inst = Function.create(function () {
	dbg(DBG_MODE, '\n++CACHE++');
	dbg(DBG_MODE, 'inst: Banas - {\n\t*', inst.banas.join('\n\t* '), '\n}');
	var args = Array.prototype.slice.call(arguments, 0);
	var bana = Cache.genBana(args);
	var result inst.cacheBana(bana, function () {
		return inst.back.apply(inst, args);
	    });
	
	dbg(DBG_MODE, '--CACHE--\n');
	
	return result;
    }, Cache.prototype, {
	back: ConstItem(back),
	banas: StatItem([
	    [],
	    [],
	    []
	]),
	results: StatItem([])
    });
}, undefined, {
    hash: Meth.trigger(function () { // workaround to delay Cache call
	return this.val || (this.val = new Cache(function () {
	    var hash;
	    for (var hash; isI(this.results.indexOf(hash = Math.random())););
	    
	    return hash;
	}));
    }),
    genBana: Meth(function (args) {
	var filledArgs = args.concat([empty, empty]);
	dbg(DBG_MODE, 'genBana: filledArgs - ', filledArgs);
	var bana = new Array(3);
	var bigArgs = args.slice(2);
	dbg(DBG_MODE, '\n++HASH++');
	bana[0] = 0 < bigArgs.length ? Cache.hash.apply(undefined, bigArgs) : empty;
	dbg(DBG_MODE, '--HASH--\n');
	bana[1] = filledArgs[0];
	bana[2] = filledArgs[1];		
	dbg(DBG_MODE, 'genBana: Bana - ', bana);
	
	return bana;
    }),
    prototype: Member(Object.create(Function.prototype, {
	add: Meth(function (bana, result) {
	    var inst = this;
	    dbg(DBG_MODE, '\n++ADD++');
	    dbg(DBG_MODE, 'add: bana - ', bana);
	    var length = bana.reduce(function (left, right, colI) {
		    dbg(DBG_MODE, 'reduce: colI - ', colI, '; right:', right);
		    return inst.banas[colI].push(right);
		}, undefined);
	    this.results[length-1] = result;
	    dbg(DBG_MODE, 'add: banas - ', this.banas, '; results - ', this.results, '; length - ', length);
	    dbg(DBG_MODE, '--ADD--\n');
	    
	    return length;
	}),
	getI: Meth(function (bana) {
	    dbg(DBG_MODE, '\n++GETI++');
	    var inst = this;
	    var matchingI = this.banas[0].reduce(function (left, right, i) {
		    dbg(DBG_MODE, '\n{{', i,'}}REDUCE: left - ', left, ' (', isI(left), ')');
		    return isI.argBack(left, function () {
			dbg(DBG_MODE, 'default: marchingI - ', bindMeth(inst, 'cmpBana', bana).argIf(i, -1));
			return bindMeth(inst, 'cmpBana', bana).argIf(i, -1);
		    });
		}, -1);
	    dbg(DBG_MODE, '--GETI--\n');
	    
	    return matchingI;
	}),
	rm: Meth(function (i) {
	    this.banas.forEach(function (banas_) {
		banas_.splice(i, 1);
	    });
	    
	    this.results.splice(i, 1);
	}),
	rmByBana: Meth(function (bana) {
	    var i = this.getI(bana);
	    this.rm(i);
	}),
	readd: Meth(function (bana, result) {
	    this.rmByBana(bana);
	    this.add(bana, result);
	}),
	cmpBana: Meth(function (bana, i) {
	    var inst = this;
	    return bana.reduce(function (left, right, colI) {
		dbg(DBG_MODE, 'cmpBana: left - ', left, '; right - ', right, '; _ - ', inst.banas[colI][i], '; result - ', right === inst.banas[colI][i]);
		return left && right === inst.banas[colI][i];
	    }, true);
	}),
	cacheBana: Meth(function (bana, generator) {
	    var i = inst.getI(bana);
	    dbg(DBG_MODE, 'cacheBana: index - ', i, '/', args);
	    var result;
	    if (isI(i)) {
		dbg(DBG_MODE, 'cacheBana: Match ...');
		result = inst.results[i];
	    } else {
		dbg(DBG_MODE, 'cacheBana: Miss ...');
		result = generator();
		inst.add(bana, result);
	    };
	    
	    return result;
	})
    }))
});
    
module.exports = new Cache(Cache); // Same arguments singleton